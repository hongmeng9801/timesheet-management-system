# 微信小程序真机测试流程

## 目录
- [测试前准备](#测试前准备)
- [真机调试设置](#真机调试设置)
- [功能测试流程](#功能测试流程)
- [性能测试](#性能测试)
- [兼容性测试](#兼容性测试)
- [问题记录与反馈](#问题记录与反馈)
- [测试报告](#测试报告)

## 测试前准备

### 1. 硬件准备

#### 测试设备清单
- **主要测试设备**
  - iPhone (iOS 最新版本)
  - Android 主流机型 (华为、小米、OPPO、vivo等)
  - 不同屏幕尺寸设备 (5.5寸、6.1寸、6.7寸等)

- **网络环境**
  - WiFi 网络
  - 4G/5G 移动网络
  - 弱网环境模拟

#### 微信版本要求
- 微信版本: 8.0.0 及以上
- 基础库版本: 3.5.7 及以上
- 确保支持最新的小程序特性

### 2. 软件准备

#### 开发者工具配置
```json
// project.config.json 确认配置
{
  "miniprogramRoot": "./",
  "projectname": "工时管理系统",
  "libVersion": "3.5.7",
  "setting": {
    "urlCheck": true,
    "es6": true,
    "enhance": true,
    "postcss": true,
    "minified": true
  }
}
```

#### 测试账号准备
- 测试用微信号 (至少2个)
- 开发者微信号
- 不同权限级别的测试账号

## 真机调试设置

### 1. 开启真机调试

#### 步骤说明
1. **微信开发者工具操作**
   ```
   工具栏 → 预览 → 真机调试
   ```

2. **生成调试二维码**
   - 选择调试类型: 普通调试/性能调试
   - 确认代码版本
   - 生成二维码

3. **手机端操作**
   ```
   微信扫码 → 确认调试 → 开始调试
   ```

### 2. 调试工具配置

#### vConsole 启用
```javascript
// app.js - 开发环境启用调试
App({
  onLaunch: function() {
    // 获取小程序环境
    const accountInfo = wx.getAccountInfoSync();
    const envVersion = accountInfo.miniProgram.envVersion;
    
    // 开发版和体验版启用调试
    if (envVersion === 'develop' || envVersion === 'trial') {
      wx.setEnableDebug({
        enableDebug: true,
        success: function() {
          console.log('vConsole 已启用');
        }
      });
    }
  }
});
```

#### 日志收集配置
```javascript
// utils/logger.js - 真机日志收集
const logger = wx.getLogManager({ level: 0 });

class RealDeviceLogger {
  static log(message, data = {}) {
    const logData = {
      timestamp: new Date().toISOString(),
      message: message,
      data: data,
      page: getCurrentPages().pop()?.route || 'unknown',
      systemInfo: wx.getSystemInfoSync()
    };
    
    logger.info('APP_LOG', logData);
    console.log('[真机日志]', logData);
  }
  
  static error(message, error = {}) {
    const errorData = {
      timestamp: new Date().toISOString(),
      message: message,
      error: error,
      stack: error.stack || 'no stack',
      page: getCurrentPages().pop()?.route || 'unknown'
    };
    
    logger.error('APP_ERROR', errorData);
    console.error('[真机错误]', errorData);
  }
}

module.exports = RealDeviceLogger;
```

## 功能测试流程

### 1. 基础功能测试

#### 应用启动测试
```javascript
// 测试检查清单
const startupTests = {
  // 1. 应用启动
  appLaunch: {
    description: '应用正常启动',
    steps: [
      '点击小程序图标',
      '观察启动画面',
      '确认首页正常显示'
    ],
    expected: '应用在3秒内完成启动',
    actual: '', // 测试时填写
    status: '' // pass/fail
  },
  
  // 2. 首页加载
  homePageLoad: {
    description: '首页内容正常加载',
    steps: [
      '检查页面布局',
      '确认数据显示',
      '测试交互功能'
    ],
    expected: '首页在2秒内完成渲染',
    actual: '',
    status: ''
  }
};
```

#### 页面导航测试
```javascript
// 导航测试用例
const navigationTests = [
  {
    name: '首页到WebView页面',
    action: '点击工时管理按钮',
    expected: 'WebView页面正常打开',
    testCode: `
      // 在首页执行
      wx.navigateTo({
        url: '/pages/webview/webview?url=https://example.com',
        success: () => console.log('导航成功'),
        fail: (err) => console.error('导航失败', err)
      });
    `
  },
  {
    name: 'WebView返回首页',
    action: '点击返回按钮',
    expected: '正常返回首页',
    testCode: `
      // 在WebView页面执行
      wx.navigateBack({
        delta: 1
      });
    `
  }
];
```

### 2. WebView 功能测试

#### H5页面加载测试
```javascript
// WebView测试脚本
const webviewTests = {
  // H5页面加载
  pageLoad: {
    testUrl: 'https://your-h5-domain.com',
    timeout: 10000, // 10秒超时
    checkPoints: [
      '页面开始加载',
      '页面加载完成',
      '页面内容显示',
      '交互功能正常'
    ]
  },
  
  // 双向通信测试
  communication: {
    h5ToMiniprogram: {
      description: 'H5向小程序发送消息',
      testMessage: {
        type: 'getUserInfo',
        data: { requestId: 'test_001' }
      }
    },
    miniprogramToH5: {
      description: '小程序向H5发送消息',
      testMessage: {
        type: 'userInfo',
        data: { userId: '123', userName: '测试用户' }
      }
    }
  }
};
```

#### 通信测试代码
```javascript
// pages/webview/webview.js - 通信测试
Page({
  data: {
    testResults: []
  },
  
  // 测试H5通信
  testH5Communication: function() {
    const testMessages = [
      { type: 'getUserInfo', data: {} },
      { type: 'getLocation', data: {} },
      { type: 'showToast', data: { title: '测试消息' } }
    ];
    
    testMessages.forEach((message, index) => {
      setTimeout(() => {
        this.sendMessageToH5(message);
        this.addTestResult(`发送消息 ${index + 1}`, message.type, 'success');
      }, index * 1000);
    });
  },
  
  // 记录测试结果
  addTestResult: function(action, type, status) {
    const result = {
      timestamp: new Date().toLocaleTimeString(),
      action: action,
      type: type,
      status: status
    };
    
    this.setData({
      testResults: [...this.data.testResults, result]
    });
  }
});
```

### 3. 网络功能测试

#### 网络请求测试
```javascript
// 网络测试用例
const networkTests = {
  // API请求测试
  apiRequests: [
    {
      name: '用户登录接口',
      url: 'https://api.example.com/login',
      method: 'POST',
      data: { username: 'test', password: 'test123' },
      expectedStatus: 200,
      timeout: 5000
    },
    {
      name: '获取用户信息',
      url: 'https://api.example.com/user/info',
      method: 'GET',
      headers: { 'Authorization': 'Bearer token' },
      expectedStatus: 200,
      timeout: 3000
    }
  ],
  
  // 网络状态测试
  networkStatus: {
    wifi: '测试WiFi环境下的网络请求',
    mobile: '测试移动网络环境下的请求',
    weak: '测试弱网环境下的请求处理'
  }
};
```

## 性能测试

### 1. 启动性能测试

#### 启动时间测量
```javascript
// app.js - 启动性能监控
App({
  globalData: {
    launchTime: Date.now(),
    performanceData: {}
  },
  
  onLaunch: function() {
    const launchTime = Date.now();
    this.globalData.launchTime = launchTime;
    
    // 记录启动时间
    console.log('应用启动时间:', launchTime);
    
    // 监控首页渲染时间
    setTimeout(() => {
      const renderTime = Date.now() - launchTime;
      this.globalData.performanceData.renderTime = renderTime;
      console.log('首页渲染耗时:', renderTime + 'ms');
      
      // 上报性能数据
      this.reportPerformance('app_launch', renderTime);
    }, 100);
  },
  
  reportPerformance: function(event, duration) {
    // 上报到性能监控平台
    wx.reportPerformance(1001, duration, {
      event: event,
      timestamp: Date.now()
    });
  }
});
```

### 2. 页面性能测试

#### 页面加载性能
```javascript
// 页面性能监控
Page({
  data: {
    loadStartTime: 0,
    loadEndTime: 0
  },
  
  onLoad: function() {
    this.setData({
      loadStartTime: Date.now()
    });
  },
  
  onReady: function() {
    const loadEndTime = Date.now();
    const loadDuration = loadEndTime - this.data.loadStartTime;
    
    this.setData({
      loadEndTime: loadEndTime
    });
    
    console.log('页面加载耗时:', loadDuration + 'ms');
    
    // 性能基准检查
    if (loadDuration > 3000) {
      console.warn('页面加载时间过长:', loadDuration + 'ms');
    }
    
    // 记录性能数据
    this.recordPerformance(loadDuration);
  },
  
  recordPerformance: function(duration) {
    const performanceData = {
      page: this.route,
      loadTime: duration,
      timestamp: Date.now(),
      deviceInfo: wx.getSystemInfoSync()
    };
    
    // 存储到本地，用于后续分析
    const existingData = wx.getStorageSync('performanceData') || [];
    existingData.push(performanceData);
    wx.setStorageSync('performanceData', existingData);
  }
});
```

### 3. 内存使用监控

#### 内存监控代码
```javascript
// utils/memory-monitor.js
class MemoryMonitor {
  static startMonitoring() {
    setInterval(() => {
      this.checkMemoryUsage();
    }, 10000); // 每10秒检查一次
  }
  
  static checkMemoryUsage() {
    try {
      const performance = wx.getPerformance();
      if (performance && performance.memory) {
        const memoryInfo = {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit,
          timestamp: Date.now()
        };
        
        console.log('内存使用情况:', memoryInfo);
        
        // 内存使用率超过80%时警告
        const usageRate = memoryInfo.used / memoryInfo.total;
        if (usageRate > 0.8) {
          console.warn('内存使用率过高:', (usageRate * 100).toFixed(2) + '%');
        }
        
        return memoryInfo;
      }
    } catch (error) {
      console.error('内存监控失败:', error);
    }
  }
}

module.exports = MemoryMonitor;
```

## 兼容性测试

### 1. 设备兼容性测试

#### 测试设备矩阵
```javascript
const deviceTestMatrix = {
  iOS: {
    devices: [
      { model: 'iPhone 12', version: 'iOS 15.0', screen: '6.1"' },
      { model: 'iPhone 13 Pro', version: 'iOS 16.0', screen: '6.1"' },
      { model: 'iPhone SE', version: 'iOS 15.0', screen: '4.7"' }
    ],
    testPoints: [
      '页面布局适配',
      '触摸交互',
      '性能表现',
      '网络请求'
    ]
  },
  Android: {
    devices: [
      { model: '华为 P40', version: 'Android 10', screen: '6.1"' },
      { model: '小米 11', version: 'Android 11', screen: '6.81"' },
      { model: 'OPPO Find X3', version: 'Android 11', screen: '6.7"' }
    ],
    testPoints: [
      '页面布局适配',
      '触摸交互',
      '性能表现',
      '网络请求'
    ]
  }
};
```

### 2. 微信版本兼容性

#### 版本检查代码
```javascript
// utils/version-check.js
class VersionChecker {
  static checkWechatVersion() {
    const systemInfo = wx.getSystemInfoSync();
    const wechatVersion = systemInfo.version;
    const SDKVersion = systemInfo.SDKVersion;
    
    console.log('微信版本:', wechatVersion);
    console.log('基础库版本:', SDKVersion);
    
    // 检查版本兼容性
    const minWechatVersion = '8.0.0';
    const minSDKVersion = '3.5.7';
    
    const isWechatSupported = this.compareVersion(wechatVersion, minWechatVersion) >= 0;
    const isSDKSupported = this.compareVersion(SDKVersion, minSDKVersion) >= 0;
    
    if (!isWechatSupported) {
      wx.showModal({
        title: '版本提示',
        content: `当前微信版本过低，建议升级到${minWechatVersion}以上版本`,
        showCancel: false
      });
    }
    
    if (!isSDKSupported) {
      console.warn('基础库版本过低，部分功能可能不可用');
    }
    
    return {
      wechatSupported: isWechatSupported,
      sdkSupported: isSDKSupported,
      versions: { wechatVersion, SDKVersion }
    };
  }
  
  static compareVersion(v1, v2) {
    const arr1 = v1.split('.');
    const arr2 = v2.split('.');
    const length = Math.max(arr1.length, arr2.length);
    
    for (let i = 0; i < length; i++) {
      const num1 = parseInt(arr1[i] || 0);
      const num2 = parseInt(arr2[i] || 0);
      
      if (num1 > num2) return 1;
      if (num1 < num2) return -1;
    }
    
    return 0;
  }
}

module.exports = VersionChecker;
```

## 问题记录与反馈

### 1. 问题记录模板

#### Bug报告格式
```javascript
const bugReportTemplate = {
  // 基本信息
  id: '', // Bug ID
  title: '', // 问题标题
  description: '', // 详细描述
  
  // 环境信息
  environment: {
    device: '', // 设备型号
    os: '', // 操作系统版本
    wechatVersion: '', // 微信版本
    sdkVersion: '', // 基础库版本
    networkType: '' // 网络类型
  },
  
  // 复现信息
  reproduction: {
    steps: [], // 复现步骤
    frequency: '', // 出现频率
    conditions: '' // 特定条件
  },
  
  // 影响评估
  impact: {
    severity: '', // 严重程度: critical/high/medium/low
    affectedUsers: '', // 影响用户范围
    businessImpact: '' // 业务影响
  },
  
  // 附加信息
  attachments: {
    screenshots: [], // 截图
    logs: [], // 日志
    videos: [] // 录屏
  },
  
  // 状态跟踪
  status: '', // 状态: open/in-progress/resolved/closed
  assignee: '', // 负责人
  createdAt: '', // 创建时间
  updatedAt: '' // 更新时间
};
```

### 2. 自动问题收集

#### 错误自动上报
```javascript
// utils/error-reporter.js
class ErrorReporter {
  static init() {
    // 监听小程序错误
    wx.onError((error) => {
      this.reportError('miniprogram_error', error);
    });
    
    // 监听未处理的Promise拒绝
    wx.onUnhandledRejection((error) => {
      this.reportError('unhandled_rejection', error);
    });
  }
  
  static reportError(type, error) {
    const errorReport = {
      type: type,
      message: error.message || error,
      stack: error.stack || '',
      timestamp: Date.now(),
      page: getCurrentPages().pop()?.route || 'unknown',
      systemInfo: wx.getSystemInfoSync(),
      userAgent: navigator.userAgent || 'unknown'
    };
    
    console.error('错误上报:', errorReport);
    
    // 发送到错误收集服务
    this.sendErrorReport(errorReport);
  }
  
  static sendErrorReport(errorReport) {
    wx.request({
      url: 'https://api.example.com/error-report',
      method: 'POST',
      data: errorReport,
      success: () => {
        console.log('错误报告发送成功');
      },
      fail: (err) => {
        console.error('错误报告发送失败:', err);
        // 存储到本地，稍后重试
        this.storeErrorLocally(errorReport);
      }
    });
  }
  
  static storeErrorLocally(errorReport) {
    try {
      const localErrors = wx.getStorageSync('localErrors') || [];
      localErrors.push(errorReport);
      
      // 只保留最近100条错误
      if (localErrors.length > 100) {
        localErrors.splice(0, localErrors.length - 100);
      }
      
      wx.setStorageSync('localErrors', localErrors);
    } catch (error) {
      console.error('本地错误存储失败:', error);
    }
  }
}

module.exports = ErrorReporter;
```

## 测试报告

### 1. 测试报告模板

#### 完整测试报告
```javascript
const testReportTemplate = {
  // 报告基本信息
  reportInfo: {
    version: '', // 测试版本
    testDate: '', // 测试日期
    tester: '', // 测试人员
    environment: '', // 测试环境
    duration: '' // 测试时长
  },
  
  // 测试概要
  summary: {
    totalTests: 0, // 总测试用例数
    passedTests: 0, // 通过用例数
    failedTests: 0, // 失败用例数
    blockedTests: 0, // 阻塞用例数
    passRate: '0%' // 通过率
  },
  
  // 功能测试结果
  functionalTests: {
    appLaunch: { status: '', issues: [] },
    navigation: { status: '', issues: [] },
    webview: { status: '', issues: [] },
    network: { status: '', issues: [] },
    storage: { status: '', issues: [] }
  },
  
  // 性能测试结果
  performanceTests: {
    launchTime: { value: '', benchmark: '3s', status: '' },
    pageLoadTime: { value: '', benchmark: '2s', status: '' },
    memoryUsage: { value: '', benchmark: '50MB', status: '' },
    networkLatency: { value: '', benchmark: '1s', status: '' }
  },
  
  // 兼容性测试结果
  compatibilityTests: {
    devices: [],
    wechatVersions: [],
    networkTypes: []
  },
  
  // 问题列表
  issues: [
    {
      id: '',
      title: '',
      severity: '',
      status: '',
      description: ''
    }
  ],
  
  // 建议和结论
  recommendations: [],
  conclusion: ''
};
```

### 2. 自动生成测试报告

#### 报告生成器
```javascript
// utils/report-generator.js
class ReportGenerator {
  static generateTestReport(testResults) {
    const report = {
      reportInfo: {
        version: wx.getAccountInfoSync().miniProgram.version,
        testDate: new Date().toISOString(),
        environment: wx.getAccountInfoSync().miniProgram.envVersion,
        systemInfo: wx.getSystemInfoSync()
      },
      
      summary: this.calculateSummary(testResults),
      functionalTests: this.analyzeFunctionalTests(testResults),
      performanceTests: this.analyzePerformanceTests(),
      issues: this.collectIssues(testResults)
    };
    
    // 保存报告到本地
    this.saveReport(report);
    
    return report;
  }
  
  static calculateSummary(testResults) {
    const total = testResults.length;
    const passed = testResults.filter(r => r.status === 'pass').length;
    const failed = testResults.filter(r => r.status === 'fail').length;
    
    return {
      totalTests: total,
      passedTests: passed,
      failedTests: failed,
      passRate: total > 0 ? ((passed / total) * 100).toFixed(2) + '%' : '0%'
    };
  }
  
  static saveReport(report) {
    const reportKey = `testReport_${Date.now()}`;
    wx.setStorageSync(reportKey, report);
    
    // 保存报告索引
    const reportIndex = wx.getStorageSync('reportIndex') || [];
    reportIndex.push({
      key: reportKey,
      date: report.reportInfo.testDate,
      version: report.reportInfo.version
    });
    wx.setStorageSync('reportIndex', reportIndex);
  }
}

module.exports = ReportGenerator;
```

## 总结

真机测试是确保小程序质量的关键环节，需要：

1. **系统性测试**: 覆盖功能、性能、兼容性等各个方面
2. **多设备测试**: 在不同设备和环境下验证
3. **问题跟踪**: 及时记录和反馈发现的问题
4. **持续改进**: 根据测试结果不断优化产品

建议在每个版本发布前都进行完整的真机测试，确保用户体验的一致性和稳定性。